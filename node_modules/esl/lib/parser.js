// Generated by CoffeeScript 1.12.7
(function() {
  var FreeSwitchParser, FreeSwitchParserError, parse_header_text, querystring, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  querystring = require('querystring');

  util = require('util');

  FreeSwitchParserError = (function(superClass) {
    extend(FreeSwitchParserError, superClass);

    function FreeSwitchParserError(error, buffer) {
      this.error = error;
      this.buffer = buffer;
      FreeSwitchParserError.__super__.constructor.call(this, JSON.stringify({
        error: this.error,
        buffer: this.buffer
      }));
      return;
    }

    return FreeSwitchParserError;

  })(Error);

  module.exports = FreeSwitchParser = (function() {
    function FreeSwitchParser(socket) {
      this.socket = socket;
      this.body_length = 0;
      this.buffer = new Buffer(0);
      this.buffer_length = 0;
      this.socket.on('data', (function(_this) {
        return function(data) {
          return _this.on_data(data);
        };
      })(this));
      this.socket.on('end', (function(_this) {
        return function() {
          return _this.on_end();
        };
      })(this));
      return;
    }

    FreeSwitchParser.prototype.capture_body = function(data) {
      var body;
      this.buffer_length += data.length;
      this.buffer = Buffer.concat([this.buffer, data], this.buffer_length);
      if (this.buffer_length < this.body_length) {
        return;
      }
      body = this.buffer.toString('utf8', 0, this.body_length);
      this.buffer = this.buffer.slice(this.body_length);
      this.buffer_length -= this.body_length;
      this.body_length = 0;
      this.process(this.headers, body);
      this.headers = {};
      this.capture_headers(new Buffer(0));
    };

    FreeSwitchParser.prototype.capture_headers = function(data) {
      var header_end, header_text;
      this.buffer_length += data.length;
      this.buffer = Buffer.concat([this.buffer, data], this.buffer_length);
      header_end = this.buffer.indexOf('\n\n');
      if (header_end < 0) {
        return;
      }
      header_text = this.buffer.toString('utf8', 0, header_end);
      this.buffer = this.buffer.slice(header_end + 2);
      this.buffer_length -= header_end + 2;
      this.headers = parse_header_text(header_text);
      if (this.headers["Content-Length"]) {
        this.body_length = parseInt(this.headers["Content-Length"], 10);
        this.capture_body(new Buffer(0));
      } else {
        this.process(this.headers);
        this.headers = {};
        this.capture_headers(new Buffer(0));
      }
    };

    FreeSwitchParser.prototype.on_data = function(data) {
      if (this.body_length > 0) {
        return this.capture_body(data);
      } else {
        return this.capture_headers(data);
      }
    };

    FreeSwitchParser.prototype.on_end = function() {
      if (this.buffer_length > 0) {
        this.socket.emit('error', new FreeSwitchParserError('Buffer is not empty at end of stream', this.buffer));
      }
    };

    return FreeSwitchParser;

  })();

  parse_header_text = function(header_text) {
    var fn, header_lines, headers, i, len, line, name, ref;
    header_lines = header_text.split('\n');
    headers = {};
    fn = function(line) {
      var name, ref, value;
      ref = line.split(/: /, 2), name = ref[0], value = ref[1];
      return headers[name] = value;
    };
    for (i = 0, len = header_lines.length; i < len; i++) {
      line = header_lines[i];
      fn(line);
    }
    if (((ref = headers['Reply-Text']) != null ? ref[0] : void 0) === '%') {
      for (name in headers) {
        headers[name] = querystring.unescape(headers[name]);
      }
    }
    return headers;
  };

  module.exports.parse_header_text = parse_header_text;

}).call(this);
