// Generated by CoffeeScript 1.12.7
(function() {
  var EventEmitter2, FreeSwitchClient, FreeSwitchParser, FreeSwitchParserError, FreeSwitchResponse, FreeSwitchServer, Wrapper, assert, connectionListener, debug, fn, i, len, name, net, parse_header_text, pkg, ref, trace,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  FreeSwitchParserError = (function(superClass) {
    extend(FreeSwitchParserError, superClass);

    function FreeSwitchParserError(args1) {
      this.args = args1;
      FreeSwitchParserError.__super__.constructor.call(this, JSON.stringify(this.args));
      return;
    }

    return FreeSwitchParserError;

  })(Error);

  connectionListener = function(call) {
    var parser;
    parser = new FreeSwitchParser(call.socket);
    call.on('CHANNEL_EXECUTE_COMPLETE', function(res) {
      var event_uuid;
      event_uuid = res.body['Application-UUID'];
      return call.emit("CHANNEL_EXECUTE_COMPLETE " + event_uuid, res);
    });
    call.on('BACKGROUND_JOB', function(res) {
      var job_uuid;
      job_uuid = res.body['Job-UUID'];
      return call.emit_later("BACKGROUND_JOB " + job_uuid, {
        body: res.body._body
      });
    });
    parser.process = function(headers, body) {
      var base, base1, base10, base2, base3, base4, base5, base6, base7, base8, base9, content_type, event, exception, i, len, msg, n, ref;
      content_type = headers['Content-Type'];
      if (content_type == null) {
        if (call.stats != null) {
          if ((base = call.stats).missing_content_type == null) {
            base.missing_content_type = 0;
          }
          call.stats.missing_content_type++;
        }
        call.emit('error.missing-content-type', new FreeSwitchParserError({
          headers: headers,
          body: body
        }));
        return;
      }
      switch (content_type) {
        case 'auth/request':
          event = 'freeswitch_auth_request';
          if (call.stats != null) {
            if ((base1 = call.stats).auth_request == null) {
              base1.auth_request = 0;
            }
            call.stats.auth_request++;
          }
          break;
        case 'command/reply':
          event = 'freeswitch_command_reply';
          if (headers['Event-Name'] === 'CHANNEL_DATA') {
            body = headers;
            headers = {};
            ref = ['Content-Type', 'Reply-Text', 'Socket-Mode', 'Control'];
            for (i = 0, len = ref.length; i < len; i++) {
              n = ref[i];
              headers[n] = body[n];
              delete body[n];
            }
          }
          if (call.stats != null) {
            if ((base2 = call.stats).command_reply == null) {
              base2.command_reply = 0;
            }
            call.stats.command_reply++;
          }
          break;
        case 'text/event-json':
          if (call.stats != null) {
            if ((base3 = call.stats).events == null) {
              base3.events = 0;
            }
            call.stats.events++;
          }
          try {
            body = body.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            body = JSON.parse(body);
          } catch (error1) {
            exception = error1;
            trace('Invalid JSON', body);
            if (call.stats != null) {
              if ((base4 = call.stats).json_parse_errors == null) {
                base4.json_parse_errors = 0;
              }
              call.stats.json_parse_errors++;
            }
            call.emit('error.invalid-json', exception);
            return;
          }
          event = body['Event-Name'];
          break;
        case 'text/event-plain':
          body = parse_header_text(body);
          event = body['Event-Name'];
          if (call.stats != null) {
            if ((base5 = call.stats).events == null) {
              base5.events = 0;
            }
            call.stats.events++;
          }
          break;
        case 'log/data':
          event = 'freeswitch_log_data';
          if (call.stats != null) {
            if ((base6 = call.stats).log_data == null) {
              base6.log_data = 0;
            }
            call.stats.log_data++;
          }
          break;
        case 'text/disconnect-notice':
          event = 'freeswitch_disconnect_notice';
          if (call.stats != null) {
            if ((base7 = call.stats).disconnect == null) {
              base7.disconnect = 0;
            }
            call.stats.disconnect++;
          }
          break;
        case 'api/response':
          event = 'freeswitch_api_response';
          if (call.stats != null) {
            if ((base8 = call.stats).api_responses == null) {
              base8.api_responses = 0;
            }
            call.stats.api_responses++;
          }
          break;
        case 'text/rude-rejection':
          event = 'freeswitch_rude_rejection';
          if (call.stats != null) {
            if ((base9 = call.stats).rude_rejections == null) {
              base9.rude_rejections = 0;
            }
            call.stats.rude_rejections++;
          }
          break;
        default:
          trace('Unhandled Content-Type', content_type);
          event = "freeswitch_" + (content_type.replace(/[^a-z]/, '_'));
          call.emit('error.unhandled-content-type', new FreeSwitchParserError({
            content_type: content_type
          }));
          if (call.stats != null) {
            if ((base10 = call.stats).unhandled == null) {
              base10.unhandled = 0;
            }
            call.stats.unhandled++;
          }
      }
      msg = {
        headers: headers,
        body: body
      };
      call.emit(event, msg);
    };
    call.emit('freeswitch_connect');
  };

  net = require('net');

  FreeSwitchServer = (function(superClass) {
    extend(FreeSwitchServer, superClass);

    function FreeSwitchServer(requestListener) {
      this.on('connection', function(socket) {
        var call;
        call = new FreeSwitchResponse(socket);
        call.once('freeswitch_connect', function() {
          var exception;
          try {
            return requestListener.call(call);
          } catch (error1) {
            exception = error1;
            return call.emit('error.listener', exception);
          }
        });
        connectionListener(call);
      });
      FreeSwitchServer.__super__.constructor.call(this);
      return;
    }

    return FreeSwitchServer;

  })(net.Server);

  exports.server = function(options, handler, report) {
    var ref, server;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      ref = [{}, options, handler], options = ref[0], handler = ref[1], report = ref[2];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug("Server: " + error);
      };
    }
    if (options.all_events == null) {
      options.all_events = true;
    }
    if (options.my_events == null) {
      options.my_events = true;
    }
    assert.ok(handler != null, "server handler is required");
    assert.strictEqual(typeof handler, 'function', "server handler must be a function");
    server = new FreeSwitchServer(function() {
      var Unique_ID, exception;
      try {
        Unique_ID = 'Unique-ID';
        this.connect().then(function(res) {
          this.data = res.body;
          this.uuid = this.data[Unique_ID];
          if (options.my_events) {
            return this.filter(Unique_ID, this.uuid);
          }
        }).then(function() {
          return this.auto_cleanup();
        }).then(function() {
          if (options.all_events) {
            return this.event_json('ALL');
          } else {
            return this.event_json('CHANNEL_EXECUTE_COMPLETE', 'BACKGROUND_JOB');
          }
        }).then(function() {
          return handler.apply(this, arguments);
        })["catch"](function() {
          return report.apply(this, arguments);
        });
      } catch (error1) {
        exception = error1;
        report(exception);
      }
    });
    debug("Ready to start " + pkg.name + " " + pkg.version + " server.");
    return server;
  };

  FreeSwitchClient = (function(superClass) {
    extend(FreeSwitchClient, superClass);

    function FreeSwitchClient() {
      var call;
      this.call = call = new FreeSwitchResponse(this);
      this.once('connect', function() {
        return connectionListener(call);
      });
      FreeSwitchClient.__super__.constructor.call(this);
      return;
    }

    return FreeSwitchClient;

  })(net.Socket);

  exports.default_password = 'ClueCon';

  exports.client = function(options, handler, report) {
    var client, ref;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      ref = [{}, options, handler], options = ref[0], handler = ref[1], report = ref[2];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug("Client report error: " + error);
      };
    }
    if (options.password == null) {
      options.password = exports.default_password;
    }
    assert.ok(handler != null, "client handler is required");
    assert.strictEqual(typeof handler, 'function', "client handler must be a function");
    client = new FreeSwitchClient();
    client.call.onceAsync('freeswitch_auth_request').then(function() {
      return this.auth(options.password);
    }).then(function() {
      return this.auto_cleanup();
    }).then(function() {
      return this.event_json('CHANNEL_EXECUTE_COMPLETE', 'BACKGROUND_JOB');
    }).then(function() {
      return handler.apply(this, arguments);
    })["catch"](function() {
      return report.apply(this, arguments);
    });
    debug("Ready to start " + pkg.name + " " + pkg.version + " client.");
    return client;
  };

  exports.reconnect = function(connect_options, options, handler, report) {
    var client, notify, reconnect, running;
    if (connect_options == null) {
      connect_options = {
        host: '127.0.0.1',
        port: 8021
      };
    }
    notify = connect_options.notify;
    client = null;
    running = true;
    reconnect = function(retry, attempt) {
      if (attempt == null) {
        attempt = 0;
      }
      if (!running) {
        debug("reconnect attempt #" + attempt + ": stopping client to ", connect_options);
        return;
      }
      debug("reconnect attempt #" + attempt + " (retry is " + retry + "ms): (re)connecting client to ", connect_options);
      if (client != null) {
        client.destroy();
      }
      client = exports.client(options, handler, report);
      client.on('error', function(error) {
        if (retry < 5000) {
          if (error.code === 'ECONNREFUSED') {
            retry = Math.floor((retry * 1200) / 1000);
          }
        }
        debug("reconnect attempt #" + attempt + ": client received `error` event: " + error.code + " — " + error + ". (Reconnecting in " + retry + "ms.)");
        if (typeof notify === "function") {
          notify('reconnecting', retry);
        }
        setTimeout((function() {
          return reconnect(retry, attempt + 1);
        }), retry);
      });
      client.on('end', function() {
        debug("reconnect attempt #" + attempt + ": client received `end` event (remote end sent a FIN packet). (Reconnecting in " + retry + "ms.)");
        if (typeof notify === "function") {
          notify('reconnecting', retry);
        }
        setTimeout((function() {
          return reconnect(retry, attempt + 1);
        }), retry);
      });
      client.on('close', function(had_error) {
        debug("reconnect attempt #" + attempt + ": client received `close` event (due to error: " + had_error + "). (Ignored.)");
        if (typeof notify === "function") {
          notify('close', had_error);
        }
      });
      client.connect(connect_options);
      return function() {
        debug("reconnect attempt #" + attempt + ": end requested by application.");
        if (typeof notify === "function") {
          notify('end');
        }
        running = false;
        return client != null ? client.end() : void 0;
      };
    };
    return reconnect(200);
  };

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  Wrapper = (function(superClass) {
    extend(Wrapper, superClass);

    function Wrapper(options) {
      var handler, notify, report, self;
      self = this;
      notify = function() {
        var args, event;
        event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (event === 'error') {
          if (self.listeners('error').length > 0) {
            self.emit('error', error);
          }
        } else {
          self.emit.apply(self, [event].concat(slice.call(args)));
        }
      };
      handler = function() {
        self.client = this;
        return self.emit('connect', this);
      };
      report = function(error) {
        return notify('error', error);
      };
      options.notify = notify;
      this.end = exports.reconnect(options, options, handler, report);
      return;
    }

    return Wrapper;

  })(EventEmitter2);

  ref = 'write send api bgapi event_json nixevent noevents filter filter_delete sendevent auth connect linger exit log nolog\nsengmsg_uuid sendmsg execute_uuid command_uuid hangup_uuid unicast_uuid\nexecute command hangup unicast'.split(/\s+/);
  fn = function(name) {
    return Wrapper.prototype[name] = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      trace("Wrapper::" + name, args);
      return (ref1 = this.client)[name].apply(ref1, args);
    };
  };
  for (i = 0, len = ref.length; i < len; i++) {
    name = ref[i];
    fn(name);
  }

  exports.createClient = function(options) {
    return new Wrapper(options);
  };

  assert = require('assert');

  FreeSwitchParser = require('./parser');

  FreeSwitchResponse = require('./response');

  parse_header_text = FreeSwitchParser.parse_header_text;

  pkg = require('../package.json');

  debug = (require('debug'))('esl:main');

  trace = (require('debug'))('esl:main:trace');

}).call(this);
