// Generated by CoffeeScript 1.12.7
(function() {
  var EventEmitter2, FreeSwitchError, FreeSwitchResponse, FreeSwitchTimeout, Promise, UUID, assert, debug, trace,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  UUID = require('uuid');

  Promise = require('bluebird');

  Promise.config({
    cancellation: true
  });

  FreeSwitchError = (function(superClass) {
    extend(FreeSwitchError, superClass);

    function FreeSwitchError(res1, args1) {
      this.res = res1;
      this.args = args1;
      FreeSwitchError.__super__.constructor.call(this);
      return;
    }

    FreeSwitchError.prototype.toString = function() {
      return "FreeSwitchError: " + (JSON.stringify(this.args));
    };

    return FreeSwitchError;

  })(Error);

  FreeSwitchTimeout = (function(superClass) {
    extend(FreeSwitchTimeout, superClass);

    function FreeSwitchTimeout(timeout1, text1) {
      this.timeout = timeout1;
      this.text = text1;
      FreeSwitchTimeout.__super__.constructor.call(this);
      return;
    }

    FreeSwitchTimeout.prototype.toString = function() {
      return "FreeSwitchTimeout: Timeout after " + this.timeout + "ms waiting for " + this.text;
    };

    return FreeSwitchTimeout;

  })(Error);

  module.exports = FreeSwitchResponse = (function(superClass) {
    extend(FreeSwitchResponse, superClass);

    function FreeSwitchResponse(socket) {
      this.socket = socket;
      assert(this.socket != null, 'Missing socket parameter');
      this.__queue = Promise.resolve(null);
      this.__later = {};
      this.closed = false;
      this.socket.once('close', (function(_this) {
        return function() {
          debug('Socket closed');
          _this.emit('socket.close');
        };
      })(this));
      this.socket.once('error', (function(_this) {
        return function(err) {
          debug('Socket Error', {
            err: err
          });
          _this.emit('socket.error', err);
        };
      })(this));
      this.once('socket.*', (function(_this) {
        return function() {
          _this.closed = true;
          _this.removeAllListeners();
          _this.__queue = null;
          _this.__later = null;
        };
      })(this));
      FreeSwitchResponse.__super__.constructor.call(this, {
        wildcard: true,
        verboseMemoryLeak: true
      });
      null;
    }

    FreeSwitchResponse.prototype.error = function(res, data) {
      debug("error: new FreeSwitchError", {
        res: res,
        data: data
      });
      return Promise.reject(new FreeSwitchError(res, data)).bind(this);
    };

    FreeSwitchResponse.prototype.default_event_timeout = 9 * 3600 * 1000;

    FreeSwitchResponse.prototype.command_timeout = 10 * 1000;

    FreeSwitchResponse.prototype.onceAsync = function(event, timeout) {
      var p, self;
      trace('onceAsync', event, timeout);
      self = this;
      return p = new Promise(function(resolve, reject, on_cancel) {
        var cleanup, on_error, on_event, on_timeout, timer;
        on_cancel(function() {
          trace("onceAsync: Cancelling " + event);
          cleanup();
        });
        on_event = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          trace("onceAsync: on_event " + event, args);
          if (!p.isPending()) {
            return;
          }
          cleanup();
          resolve.apply(self, args);
        };
        on_error = function(error) {
          trace("onceAsync: on_error " + event, error);
          if (!p.isPending()) {
            return;
          }
          cleanup();
          reject.call(self, error != null ? error : new Error("Socket closed while waiting for " + event));
        };
        on_timeout = function() {
          trace("onceAsync: on_timeout " + event);
          if (!p.isPending()) {
            return;
          }
          cleanup();
          reject.call(self, new FreeSwitchTimeout(timeout, "event " + event));
        };
        cleanup = function() {
          self.removeListener(event, on_event);
          self.removeListener('socket.*', on_error);
          clearTimeout(timer);
        };
        self.once(event, on_event);
        self.once('socket.*', on_error);
        if (timeout != null) {
          timer = setTimeout(on_timeout, timeout);
        }
      }).bind(this);
    };

    FreeSwitchResponse.prototype.enqueue = function(f) {
      if (this.__queue == null) {
        return this.error({}, {
          when: 'enqueue on closed socket'
        });
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.__queue = _this.__queue.then(function() {
            return f();
          }).then(resolve, reject);
        };
      })(this)).bind(this);
    };

    FreeSwitchResponse.prototype.waitAsync = function(event, timeout) {
      var p;
      if ((this.__later != null) && event in this.__later) {
        p = Promise.resolve(this.__later[event]);
        delete this.__later[event];
        return p.bind(this);
      } else {
        return this.onceAsync(event, timeout);
      }
    };

    FreeSwitchResponse.prototype.emit_later = function(event, data) {
      var handled;
      handled = this.emit(event, data);
      if ((this.__later != null) && !handled) {
        this.__later[event] = data;
      }
      return handled;
    };

    FreeSwitchResponse.prototype.write = function(command, args) {
      var p;
      if (this.closed) {
        return this.error({}, {
          when: 'write on closed socket',
          command: command,
          args: args
        });
      }
      p = new Promise((function(_this) {
        return function(resolve, reject) {
          var error, key, text, value;
          try {
            trace('write', {
              command: command,
              args: args
            });
            text = command + "\n";
            if (args != null) {
              for (key in args) {
                value = args[key];
                text += key + ": " + value + "\n";
              }
            }
            text += "\n";
            _this.socket.write(text, 'utf8');
            resolve(null);
          } catch (error1) {
            error = error1;
            reject(error);
          }
        };
      })(this));
      return p.bind(this);
    };

    FreeSwitchResponse.prototype.send = function(command, args, timeout) {
      if (timeout == null) {
        timeout = this.command_timeout;
      }
      if (this.closed) {
        return this.error({}, {
          when: 'send on closed socket',
          command: command,
          args: args
        });
      }
      return this.enqueue((function(_this) {
        return function() {
          var p, q;
          p = _this.onceAsync('freeswitch_command_reply', timeout)["catch"](function(error) {
            debug("send: response " + error, {
              command: command,
              args: args
            });
            return null;
          });
          q = _this.write(command, args)["catch"](function(error) {
            debug("send: write " + error, {
              command: command,
              args: args
            });
            p.cancel();
            return Promise.reject(error);
          });
          return q.then(function() {
            return p;
          }).then(function(res) {
            var reply;
            trace('send: received reply', {
              command: command,
              args: args
            });
            reply = res != null ? res.headers['Reply-Text'] : void 0;
            if (reply == null) {
              trace('send: no reply', {
                command: command,
                args: args
              });
              return _this.error(res, {
                when: 'no reply to command',
                command: command,
                args: args
              });
            }
            if (reply.match(/^-/)) {
              debug('send: failed', reply, {
                command: command,
                args: args
              });
              return _this.error(res, {
                when: 'command reply',
                reply: reply,
                command: command,
                args: args
              });
            }
            trace('send: success', {
              command: command,
              args: args
            });
            return res;
          });
        };
      })(this));
    };

    FreeSwitchResponse.prototype.end = function() {
      trace('end');
      this.closed = true;
      this.socket.end();
      return null;
    };

    FreeSwitchResponse.prototype.api = function(command, timeout) {
      trace('api', {
        command: command
      });
      if (this.closed) {
        return this.error({}, {
          when: 'api on closed socket',
          command: command
        });
      }
      return this.enqueue((function(_this) {
        return function() {
          var p, q;
          p = _this.onceAsync('freeswitch_api_response', timeout)["catch"](function(error) {
            debug("api: response " + error, command);
            return null;
          });
          q = _this.write("api " + command)["catch"](function(error) {
            debug("api: write " + error, command);
            p.cancel();
            return Promise.reject(error);
          });
          return q.then(function() {
            return p;
          }).then(function(res) {
            var ref, reply;
            trace('api: response', {
              command: command
            });
            reply = res != null ? res.body : void 0;
            if (reply == null) {
              debug('api: no reply', {
                command: command
              });
              return _this.error(res, {
                when: 'no reply to api',
                command: command
              });
            }
            if (reply.match(/^-/)) {
              debug('api response failed', {
                reply: reply,
                command: command
              });
              return _this.error(res, {
                when: 'api response',
                reply: reply,
                command: command
              });
            }
            res.uuid = (ref = reply.match(/^\+OK ([\da-f-]{36})/)) != null ? ref[1] : void 0;
            return res;
          });
        };
      })(this));
    };

    FreeSwitchResponse.prototype.bgapi = function(command, timeout) {
      trace('bgapi', {
        command: command,
        timeout: timeout
      });
      if (this.closed) {
        return this.error({}, {
          when: 'bgapi on closed socket',
          command: command
        });
      }
      return this.send("bgapi " + command).then((function(_this) {
        return function(res) {
          var error, r, ref, reply;
          error = function() {
            return _this.error(res, {
              when: "bgapi did not provide a Job-UUID",
              command: command
            });
          };
          if (res == null) {
            return error();
          }
          reply = res.headers['Reply-Text'];
          r = reply != null ? (ref = reply.match(/\+OK Job-UUID: (.+)$/)) != null ? ref[1] : void 0 : void 0;
          if (r == null) {
            r = res.headers['Job-UUID'];
          }
          if (r == null) {
            return error();
          }
          trace('bgapi retrieve', r);
          return _this.waitAsync("BACKGROUND_JOB " + r, timeout);
        };
      })(this));
    };

    FreeSwitchResponse.prototype.event_json = function() {
      var events;
      events = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.send("event json " + (events.join(' ')));
    };

    FreeSwitchResponse.prototype.nixevent = function() {
      var events;
      events = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.send("nixevent " + (events.join(' ')));
    };

    FreeSwitchResponse.prototype.noevents = function() {
      return this.send("noevents");
    };

    FreeSwitchResponse.prototype.filter = function(header, value) {
      return this.send("filter " + header + " " + value);
    };

    FreeSwitchResponse.prototype.filter_delete = function(header, value) {
      if (value != null) {
        return this.send("filter delete " + header + " " + value);
      } else {
        return this.send("filter delete " + header);
      }
    };

    FreeSwitchResponse.prototype.sendevent = function(event_name, args) {
      return this.send("sendevent " + event_name, args);
    };

    FreeSwitchResponse.prototype.auth = function(password) {
      return this.send("auth " + password);
    };

    FreeSwitchResponse.prototype.connect = function() {
      return this.send("connect");
    };

    FreeSwitchResponse.prototype.linger = function() {
      return this.send("linger");
    };

    FreeSwitchResponse.prototype.exit = function() {
      return this.send("exit");
    };

    FreeSwitchResponse.prototype.log = function(level) {
      if (level != null) {
        return this.send("log " + level);
      } else {
        return this.send("log");
      }
    };

    FreeSwitchResponse.prototype.nolog = function() {
      return this.send("nolog");
    };

    FreeSwitchResponse.prototype.sendmsg_uuid = function(uuid, command, args) {
      var execute_text, options;
      options = args != null ? args : {};
      options['call-command'] = command;
      execute_text = uuid != null ? "sendmsg " + uuid : 'sendmsg';
      return this.send(execute_text, options);
    };

    FreeSwitchResponse.prototype.sendmsg = function(command, args) {
      return this.sendmsg_uuid(null, command, args);
    };

    FreeSwitchResponse.prototype.execute_uuid = function(uuid, app_name, app_arg, loops, event_uuid) {
      var options;
      options = {
        'execute-app-name': app_name,
        'execute-app-arg': app_arg
      };
      if (loops != null) {
        options.loops = loops;
      }
      if (event_uuid != null) {
        options['Event-UUID'] = event_uuid;
      }
      return this.sendmsg_uuid(uuid, 'execute', options);
    };

    FreeSwitchResponse.prototype.command_uuid = function(uuid, app_name, app_arg, timeout) {
      var event, event_uuid, p, q;
      if (timeout == null) {
        timeout = this.default_command_timeout;
      }
      if (app_arg == null) {
        app_arg = '';
      }
      event_uuid = UUID.v4();
      event = "CHANNEL_EXECUTE_COMPLETE " + event_uuid;
      p = this.onceAsync(event, timeout)["catch"](function(error) {
        debug("command_uuid: response " + error, uuid, app_name, app_arg);
        return null;
      });
      q = this.execute_uuid(uuid, app_name, app_arg, null, event_uuid)["catch"](function(error) {
        debug("command_uuid: execute_uuid " + error, uuid, app_name, app_arg);
        p.cancel();
        return Promise.reject(error);
      });
      return q.then(function() {
        return p;
      });
    };

    FreeSwitchResponse.prototype.hangup_uuid = function(uuid, hangup_cause) {
      var options;
      if (hangup_cause == null) {
        hangup_cause = 'NORMAL_UNSPECIFIED';
      }
      options = {
        'hangup-cause': hangup_cause
      };
      return this.sendmsg_uuid(uuid, 'hangup', options);
    };

    FreeSwitchResponse.prototype.unicast_uuid = function(uuid, args) {
      return this.sendmsg_uuid(uuid, 'unicast', args);
    };

    FreeSwitchResponse.prototype.execute = function(app_name, app_arg) {
      return this.execute_uuid(null, app_name, app_arg);
    };

    FreeSwitchResponse.prototype.command = function(app_name, app_arg) {
      return this.command_uuid(null, app_name, app_arg);
    };

    FreeSwitchResponse.prototype.hangup = function(hangup_cause) {
      return this.hangup_uuid(null, hangup_cause);
    };

    FreeSwitchResponse.prototype.unicast = function(args) {
      return this.unicast_uuid(null, args);
    };

    FreeSwitchResponse.prototype.auto_cleanup = function() {
      var linger_delay;
      this.once('freeswitch_disconnect_notice', function(res) {
        trace('auto_cleanup: Received ESL disconnection notice', res);
        switch (res.headers['Content-Disposition']) {
          case 'linger':
            trace('Sending freeswitch_linger');
            this.emit('freeswitch_linger');
            break;
          case 'disconnect':
            trace('Sending freeswitch_disconnect');
            this.emit('freeswitch_disconnect');
            break;
          default:
            trace('Sending freeswitch_disconnect');
            this.emit('freeswitch_disconnect');
        }
      });
      linger_delay = 4000;
      this.once('freeswitch_linger', function() {
        trace('auto_cleanup/linger');
        if (this.emit('cleanup_linger')) {
          debug('auto_cleanup/linger: cleanup_linger processed, make sure you call exit()');
        } else {
          trace("auto_cleanup/linger: exit() in " + linger_delay + "ms");
          setTimeout((function(_this) {
            return function() {
              trace('auto_cleanup/linger: exit()');
              _this.exit()["catch"](function() {
                return true;
              });
            };
          })(this), linger_delay);
        }
      });
      this.once('freeswitch_disconnect', function() {
        trace('auto_cleanup/disconnect');
        if (this.emit('cleanup_disconnect', this)) {
          debug('auto_cleanup/disconnect: cleanup_disconnect processed, make sure you call end()');
        } else {
          trace('auto_cleanup/disconnect: end()');
          this.end();
        }
      });
      return null;
    };

    return FreeSwitchResponse;

  })(EventEmitter2);

  assert = require('assert');

  debug = (require('debug'))('esl:response');

  trace = (require('debug'))('esl:response:trace');

}).call(this);
